<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Keeper Of Tomes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Keeper Of Tomes</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 19 Jan 2026 01:18:50 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 19 Jan 2026 01:18:50 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[General Overview]]></title><description><![CDATA[Provides a file-system snapshot and update tracking system. Designed to record file metadata and hashes for directories, detect additions, removals, updates, and renames, and maintain serialized snapshot files for fast reloading. Uses xxHash64 for high-performance hashing and supports asynchronous processing of large directories.Static class providing a simple interface for snapshotting directories.
Methods: Creates a snapshot of a directory, or updates an existing snapshot if it already exists.
Parameters: directoryToScan: Full or relative path of the directory to scan. snapshotRoot: Root folder where snapshots are stored. snapshotId: Optional identifier to name the snapshot file. Defaults to the directory name. Returns: Functions.SnapshotInfo
Contains sets of added, removed, updated files, and renamed file pairs. Empty if snapshot is created for the first time. Contains the underlying logic for managing snapshots and file hashing.
FileEntry: Represents a single file in a snapshot. string Path — Full path of the file. long Size — File size in bytes. DateTime LastWriteUtc — Last write time in UTC. ulong Hash — xxHash64 hash of the file content. Snapshot: Represents a full directory snapshot. Dictionary&lt;string, DateTime&gt; LastScan — Tracks last write times for files. List&lt;FileEntry&gt; Data — List of FileEntry objects representing files in the snapshot. string DirectoryPath — Path of the directory being snapshot. SnapshotInfo: Struct for reporting changes between snapshots. HashSet&lt;string&gt; AddedFiles HashSet&lt;string&gt; RemovedFiles HashSet&lt;string&gt; UpdatedFiles HashSet&lt;(string oldPath, string newPath)&gt; UpdatedFileDetails — Renamed or moved files. Task SaveDirectorySnapshot(string directoryPath, string pathToSaveTo)
Creates a new snapshot of the specified directory. Scans files in chunks and computes hashes. Task&lt;SnapshotInfo&gt; UpdateDirectorySnapshot(string snapshotFilePath)
Updates an existing snapshot by scanning the directory and comparing with the previous snapshot. Detects added, removed, updated, and renamed files. Task&lt;SnapshotInfo&gt; UpdateSingleFile(string filePath, string snapshotFilePath)
Updates a single file in an existing snapshot. Automatically updates hash and last-write metadata. // Define the directory to scan and where snapshots are stored
string directoryToScan = @"C:\Users\WalkerDev\Downloads";
string snapshotRoot = Path.Combine(Directory.GetCurrentDirectory(), "Snapshots");
// Create or update a snapshot for a directory
var snapshotInfo = await Keeper.SnapshotDirectory( directoryToScan, snapshotRoot
);
Console.WriteLine($"Snapshot completed. Added: {snapshotInfo.AddedFiles.Count}, Removed: {snapshotInfo.RemovedFiles.Count}, Updated: {snapshotInfo.UpdatedFiles.Count}");
// Load an existing snapshot file for inspection
string snapshotFile = Path.Combine(snapshotRoot, Path.GetFileName(directoryToScan) + ".snapshot"); if (File.Exists(snapshotFile))
{ var snapshot = await BinaryConverter.NCByteArrayToObjectAsync&lt;Functions.Snapshot&gt;( await File.ReadAllBytesAsync(snapshotFile) ); Console.WriteLine($"Loaded snapshot for directory: {snapshot.DirectoryPath}"); Console.WriteLine($"Total files: {snapshot.Data.Count}"); Console.WriteLine("Sample files:"); foreach (var file in snapshot.Data.Count &gt; 5 ? snapshot.Data.GetRange(0, 5) : snapshot.Data) { Console.WriteLine($" - {file.Path} ({file.Size} bytes, last modified {file.LastWriteUtc})"); }
}
else
{ Console.WriteLine("Snapshot file not found!");
}
// Optionally, update the snapshot and see what changed
var updateResult = await Functions.UpdateDirectorySnapshot(snapshotFile);
Console.WriteLine($"Added: {updateResult.AddedFiles.Count}");
Console.WriteLine($"Removed: {updateResult.RemovedFiles.Count}");
Console.WriteLine($"Updated: {updateResult.UpdatedFiles.Count}");
]]></description><link>manual/general-overview.html</link><guid isPermaLink="false">Manual/General Overview.md</guid><pubDate>Mon, 19 Jan 2026 01:18:28 GMT</pubDate></item><item><title><![CDATA[Welcome]]></title><description><![CDATA[ <img alt="Keeper Of Tomes" src="assets/keeperoftomes.png" referrerpolicy="no-referrer" target="_self" style="max-width: 100%;"> A seer for your files, watching over every file and remembering its every change even without constant observation. The Keeper Of Tomes is a simple yet powerful system which allows developers to keep track of updated files on a directory with a high level of accuracy. It was created for the XRUIOS (Our Cross Platform Framework/OS/Abstraction Layer). Windows • Linux • Easy To Add Platforms • Fully Offline • Post Quantum Computing Resistant • No BS
The Keeper of Tomes maintains a cryptographically-verified ledger of every file in a directory:
Observed files – your documents, media, projects (all scanned and tracked) Snapshot ledger – the keeper’s immutable record of file state (hashes, sizes, timestamps) All operations use async, chunked processing with xxHash64 for fast, deterministic file fingerprints.The Keeper:
Records every file’s size, last-modified timestamp, and hash in a snapshot Detects added, removed, renamed, or modified files automatically Updates snapshots incrementally — unchanged files are skipped for maximum performance Guarantees consistency even if files are renamed or partially overwritten during scanning
<br> <a href="https://github.com/Walker-Industries-RnD/Plagues-Protocol" target="_self" rel="noopener nofollow" class="is-unresolved"><strong></strong></a>View on GitHub • <a href="https://walkerindustries.xyz" target="_self" rel="noopener nofollow" class="is-unresolved">Walker Industries</a> • <a href="https://discord.gg/H8h8scsxtH" target="_self" rel="noopener nofollow" class="is-unresolved">Discord</a> • <a href="https://www.patreon.com/walkerdev" target="_self" rel="noopener nofollow" class="is-unresolved">Patreon</a> <a href="https://github.com/Walker-Industries-RnD/Plagues-Doctor" target="_self" rel="noopener nofollow" class="is-unresolved"><strong></strong></a>Use Plagues Doctor; A CMD Tool To Easily Use Plagues Protocol • ---
Pariah Cybersecurity + It's Requirements
Standart.Hash.xxHash
// Define the directory to scan and the snapshot file path
string directoryToScan = @"C:\Users\WalkerDev\Downloads";
string snapshotPath = Path.Combine(Directory.GetCurrentDirectory(), "Downloads.snapshot");
// Save a snapshot of the directory (initial catalog of files)
await Functions.SaveDirectorySnapshot(directoryToScan, Directory.GetCurrentDirectory());
Console.WriteLine($"Snapshot saved to '{snapshotPath}'");
// Load the snapshot and inspect it
if (File.Exists(snapshotPath))
{ var snapshotBytes = await BinaryConverter.NCByteArrayToObjectAsync&lt;Functions.Snapshot&gt;(await File.ReadAllBytesAsync(snapshotPath)); Console.WriteLine($"Loaded snapshot of directory: {snapshot.DirectoryPath}"); Console.WriteLine($"Total files: {snapshot.Data.Count}"); Console.WriteLine("Sample files:"); foreach (var file in snapshot.Data.Count &gt; 5 ? snapshot.Data.GetRange(0, 5) : snapshot.Data) { Console.WriteLine($" - {file.Path} ({file.Size} bytes, last modified {file.LastWriteUtc})"); }
}
else
{ Console.WriteLine("Snapshot file not found!");
} // Optionally, update an existing snapshot
var updateResult = await Functions.UpdateDirectorySnapshot(snapshotPath); Console.WriteLine($"Added: {updateResult.AddedFiles.Count}");
Console.WriteLine($"Removed: {updateResult.RemovedFiles.Count}");
Console.WriteLine($"Updated: {updateResult.UpdatedFiles.Count}"); Note: The first snapshot creation will always take longer, as every file in the directory must be read and hashed. Subsequent updates are much faster since only changed or new files are processed.<br>Code: <a data-tooltip-position="top" aria-label="https://raw.githubusercontent.com/non-ai-licenses/non-ai-licenses/main/NON-AI-MPL-2.0" rel="noopener nofollow" class="external-link is-unresolved" href="https://raw.githubusercontent.com/non-ai-licenses/non-ai-licenses/main/NON-AI-MPL-2.0" target="_self">NON-AI MPL 2.0</a>
Artwork: — NO AI training. NO reproduction. NO exceptions.<br><img style="margin-left: 20px; margin-bottom: 20px;" align="center" src="https://github.com/Walker-Industries-RnD/Malicious-Affiliation-Ban/blob/main/WIBan.png?raw=true" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Unauthorized use of the artwork — including but not limited to copying, distribution, modification, or inclusion in any machine-learning training dataset — is strictly prohibited and will be prosecuted to the fullest extent of the law.
]]></description><link>welcome.html</link><guid isPermaLink="false">Welcome.md</guid><pubDate>Sun, 18 Jan 2026 10:44:39 GMT</pubDate><enclosure url="assets/keeperoftomes.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="assets/keeperoftomes.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[KeeperOfTomes]]></title><description><![CDATA[<img src="assets/keeperoftomes.png" target="_self">]]></description><link>assets/keeperoftomes.html</link><guid isPermaLink="false">Assets/KeeperOfTomes.png</guid><pubDate>Sun, 18 Jan 2026 10:27:02 GMT</pubDate><enclosure url="assets/keeperoftomes.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="assets/keeperoftomes.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[walkerdev]]></title><description><![CDATA[<img src="assets/walkerdev.png" target="_self">]]></description><link>assets/walkerdev.html</link><guid isPermaLink="false">Assets/walkerdev.png</guid><pubDate>Wed, 10 Dec 2025 02:15:42 GMT</pubDate><enclosure url="assets/walkerdev.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="assets/walkerdev.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>